盒子模型：标准盒子、怪异盒子width包含border+padding

水平垂直居中
1.display:flex;align-items:center;justify-content:center
2.display:table-cell;vertical-align:middle;text-align:center
3.position:absolute:top:50%;left:50%;
margin-top: -25px; /* 高度的一半 */;margin-left: -25px; /* 宽度的一半 */需要知道元素宽高；
transform: translate(-50%,-50%);不需要宽高
4.position:absolute;top:0;left:0;right:0;bottom:0;lmargin:auto 需要宽高确认
行内元素：text-align:center;line-height:height 但是这种方法只能用于单行文本。

清除浮动的方法
1、overflow: hidden
2、增加额外标签，然后添加属性clear: both（块级元素）
3、给父元素添加高度
4、给所有元素添加浮动
5、使用display: inline-block；margin:0 auto失效
6、使用<br clear="both">
因为br自带clear属性，所以使用它可以解决浮动。这跟添加空标签一样，多了很多无用标签，也不推荐。
7:万能清除
.clearfix::after {
content: ".";
clear: both;
display: block;
overflow: hidden;
font-size: 0;
height: 0;
}
.clearfix {
zoom: 1;
}
8、设置overflow: auto
这个跟设置hidden差不多，缺点就是不能自定义高度了。
9、设置display: table

权重计算
第一等：代表内联样式，如: style=””，权值为1000。
第二等：代表ID选择器，如：#content，权值为0100。
第三等：代表类，伪类和属性选择器，如.content，权值为0010。
第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。
通配符、子选择器、相邻选择器等的。如*、>、+,权值为0000。
继承的样式没有权值。
在权重相同的情况下，后面的样式会覆盖掉前面的样式。
通配符、子选择器、相邻选择器等的。虽然权值为0000，但是也比继承的样式优先。
important权重最高

flex:弹性布局
flex-direction 主轴方向
row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。

flex-wrap 换行？
nowrap（默认）：不换行。
wrap：换行，第一行在上方。
wrap-reverse：换行，第一行在下方。

flex-flow 前两个属性的简写

justify-content 项目在主轴的对齐方式
flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中 左右两边距离边框距离相等
space-between：两端对齐，项目之间的间隔都相等。左右两边距离边框距离为零
space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

align-items 交叉轴对齐方式
flex-start：交叉轴的起点对齐。
flex-end：交叉轴的终点对齐。
center：交叉轴的中点对齐。
baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

align-content 多跟轴线的对齐方式
flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴。

order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
.item {
order: <integer>;
    }

    flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
    .item {
    flex-grow: <number>; /* default 0 */
        }
        如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

        .item {
        flex-shrink: <number>; /* default 1 */
            }
            flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将等比缩小。为零则不缩小

            .item {
            flex-basis: <length> | auto; /* default auto */
                }
                它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
                flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）

                flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
                .item {
                flex: none | [ <'flex-grow'>
                    <'flex-shrink'>? || <'flex-basis'> ]
                            }
                            该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)

                            align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
                            .item {
                            align-self: auto | flex-start | flex-end | center | baseline | stretch;
                            }

                            什么是BFC、可以解决哪些问题
                            <!-- https://www.cnblogs.com/huchangwu/p/11947719.html
一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。
一个块格式化上下文由以下之一创建：

根元素或其它包含它的元素
浮动元素 (元素的 float 不是 none)
绝对定位元素 (元素具有 position 为 absolute 或 fixed)
内联块 (元素具有 display: inline-block)
表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)
表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)
具有overflow 且值不是 visible 的块元素，
display: flow-root
column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。
一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。
块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 -->

                            BFC：独立渲染区域 一套布局规则。
                            规则:BFC区域浮动元素也要参与高度计算、内部box垂直方向排列、内部box触碰到BFC的左边缘或右边缘、BFC容器中的子元素不会影响外面的元素、box垂直方向的距离由margin决定，同一个BFC相邻的margin会重叠、BFC区域不会与float重叠
                            bfc疑问：为什么BFC内部的float不是垂直排列
                            作用：解决重叠、多栏布局、清除浮动
                            1、float的值不是none。
                            2、position的值不是static或者relative。
                            3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex
                            4、overflow的值不是visible
                            创建BFC

                            实现自适应的正方形 vw和padding-bottom
                            .vw {
                            width: 50%;
                            height: 50vw;
                            background: #ccc;
                            }

                            .placeholder{
                            width: 100%;
                            padding-bottom: 100%; // padding 百分比相对于父元素宽度来计算
                            height: 0; // 避免被内容撑开多余的高度
                            }

                            实现三角形
                            .item{
                            width:0;
                            height:0;
                            border:50px solid transparent;
                            border-top-color:black
                            }
                            带边框三角形 三角箭头 定位叠加。

                            position属性5个
                            static, inherit, relative, absolute, fixed

                            三栏布局
                            圣杯 双飞翼 flex 绝对定位布局（同圣杯。center） table-cell布局
                            绝对定位的center与圣杯不一样
                            .center {
                            position: absolute;
                            left: 200px;
                            right: 200px;
                            top: 0;
                            bottom: 0;
                            }

                            双栏
                            flex BFC display:inline-block display:table 负margin（优先加载主体内容）


                            FBC布局与普通文档流布局区别 ：
                            普通文档流布局规则
                            1.浮动的元素是不会被父级计算高度
                            2.非浮动元素会覆盖浮动元素的位置
                            3.margin会传递给父级
                            4.两个相邻元素上下margin会重叠

                            BFC布局规则
                            1.浮动的元素会被父级计算高度（父级触发了BFC）
                            2.非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）
                            3.margin不会传递给父级（父级触发了BFC）
                            4.两个相邻元素上下margin会重叠（给其中一个元素增加一个父级，然后让他的父级触发

                            #anim {
                            width: 100px;
                            height: 100px;
                            background-color: pink;
                            animation: go 2s ease 0s 2 ; /*声明动画*/
                            }

                            /*定义动画*/
                            @keyframes go {
                            from { /*0%*/
                            transform: translateX(0px);
                            }
                            to { /*100%*/
                            transform: translateX(100px);
                            }
                            }