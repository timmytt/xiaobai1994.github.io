var vDom=<h1>hello React</h1>（js的扩展语法）
ReactDOM.render(vDom,document.getElementById('test'))
react.js react的核心库
react-dom.js 提供操作DOM的react扩展库
babel.min.js 解析jsx语法转化为纯js语法的库 需要加type="text/bable"
babel被facebook收购 添加了新的功能
React Developer react的调试工具
React.createElement('h1',{id:'myTitle'},'hello') react创建虚拟dom API 'hello'可以用简单js代替
jsx中{}表示动态值 例如：<h3 id={vb}>{vb}</h3> 全称 javascript XML。会被bable转化为React.createElement。jsx作用在react中创建虚拟dom，产生的是js对象


react提供api创建特殊的js对象（DOM虚拟dom） 都会被转化成真实DOM 编码时操作虚拟DOM相关数据 即可被react转化为真实dom变化而更新界面

面向组件编程

React创建组件
1、工厂函数(简单组件) 有状态就不能用工厂函数了 没有this
function Mycomponent(props){
return <h2>xiangyi</h2> //必须返回虚拟dom
}
2、渲染组件标签
ReactDom.render('
<Mycomponent />',document.getElementById())

ES6类组件(较为复杂) 继承react的组件类
ReactDOM.render(element, container[, callback])
import react,{Component} from 'react'

Class Mycomponent extend React.Component{
render(){
return
}
}

组件对象的属性
props
refs
state

1、state （用箭头函数最佳）
Class Mycomponent extend React.Component{
constructor(props){ //参数固定写法 组件传值视频中没有传也可使用
super(props)
this.state={
isLike:false
}
//将新增方法中的this强制绑定为组件对象
this.handleClick=this.handleClick.bind(this) //返回新的函数 要赋值回去
}
handleClick(){ //新增的组件内方法 新增方法内部this不是组件对象 而是undefined
const isLike=!this.state.isLike
this.setState({isLike}) //更新组件对象 this不是组件对象
}
render(){ //重写组件类的方法
const isLike=this.state.isLike //读取状态
//const {isLike}=this.state
return <h2 onClick={this.handleClick}>{isLike?'1':'2 '}</h2> //自己封装的事件 不是原生的事件。
this指向组件对象（或者在这里绑定this.handleClick.bind(this)） render很多次 这种写法效率很低。每render一次都会bind一次
}
}

2、props 组件接受的属性
function Person(props){
return <h2>{props.name}</h2>
}
Person.defaultProps={
name:'zhuangtiantian' //指定默认值
}
Person.propTypes={
name:propTypes.string.isRequired //指定属性的类型和必要性 15.5之后被弃用 使用prop-types库代替 官方有地址引入
}

const person={name:'xiangyi'}
ReactDOM.render('
<Person name={person.name} />','') 可以使用 {...person}

class的写法 render中this.props.name获取


3.refs
与vue用法一样 react不建议这样写
不同的是react ref中可以接受一个回调函数{input=>this.input=input} 初始渲染将这个input绑定到组件上 事件中可直接this.input获取
事件都有形参event event.target.value也可以获取到值

只能有一个跟标签
组件组合使用 渲染顶层组件 将其他组件放在render中即可渲染
数据放在哪个组建的饿依据：
哪个组件需要使用（给自己）还是哪些组件需要使用 （给共同的父组件）
setState才能更新状态
bool func props的类型
子传父 父组件发送自己的饿函数给子组件 子组件props接收后在自己的方法里触发。自定义的方法里用到this就需要绑定一下。vue可以吗？
react的onChange 与 onInput一样

样式style={{opactiy:opactiy}}

初始化生命周期
Iitial render --- constructor ---componentWillMount() --- render ---componentDidMount
ReactDOM.unmountComponentAtNode(dom) 移除组件
更新生命周期：componentWillReceiveProps() shouldComponentUpdate() componentWillUpdate() render() ---componentDidUpdate()
移除组件--- componentWillUnmount

父子组建的生命周期：
当父组建 render 时遇到子组件，然后进入子组件的生命周期，当执行完子组件生命周期中的componentDidMount 时会回到父组建继续执行父组建未完成的生命周期。

虚拟dom：减少操作真实dom的次数
diff算法：减少更新的区域

初始化需要创建虚拟dom再转化为真实dom 所以第一次渲染的性能不如原生
setState的原因是产生新的状态便于虚拟dom比较
npm i -g create-react-app react的脚手架 全局下载的特点 所有的应用都看得见 npm root -g 下载的根目录
create-react-app 名字 npm run start run（可以省略）

react脚手架中可以直接写
state={} 不用写constructor super this.state
需要下载prop-types 使用时定义在文件的最外面（不推荐）组件.propTypes={} 也可以和render平级 static propTypes={} 给组件类添加。若没有static就是给组件对象添加
绑定事件对象 与render平级 fn=()=>{} 也可以调用时使用箭头函数 render中获取的数据实时更新、获取？？ p23

<React.Fragment>   </React.Fragment> 空标签
fetch 不是使用xmlhttprequest对象提交请求 window原生就可以用 较新浏览器才有 fetch.js兼容

父组件render --- componentWillReceiveProps(nextProps)（可监听props变化）
pubsub.js react消息的订阅发布机制库
Pubsub.subscribe('事件名',fn(msg,data)) 订阅 msg:事件名 data：数据 ---componentDidMount中订阅
Pubsub.publish('事件名',args) 发布 触发事件
redux
react-router 专门实现spa应用 路由 映射关系 3个版本 web native anywhere

组件
npm i -s react-route-dom
render(

(<BrowserRouter>
  <App />
</BrowserRouter>),dom
)


<Switch>
  <Route path='/home' component={home}></Route>
  <Route path='/home1' component={home1}></Route>
  <Redirect to='/home'></Redirect> 重定向 可以用于多层路由指定显示子路由.
</Switch>

{...this.props} 接受所有传递的属性
使用一个时用switch

import {Navlink,Switch,Route} from 'react-router-dom'
props ：location history match。非路由链接传递数据 /:/id <a href=''></a> 会刷新。 路由链接 <NavLink to={}></NavLink> 不会刷新跳转

find()函数

react函数不能使用this

Ant-Design 蚂蚁金服 两套 移动 pc

移动端点击300毫秒延迟 可以click 没有延迟


redux js插件库 做状态管理的 不是react的 都可以用
create.store() 创建一个store对象 入参为reducer 调用返回初始的state
总体原则 能不用就不用 不用比较吃力就使用。
import {createStore} from 'redux'
import 文件 from ''
const store=createStore(文件)

redux维护
state reducer（老的状态 生成新状态）
核心方法
getState() dispatch(action) subscribe(listener) 消息订阅发布 渲染组件 注册监听 当产生新的state 自动调用
store.getState()获取组件状态
store.subscribe(function(){ReactDom.render()}) 监听store中的状态变化 自动调用 刷新页面
action 行为 {type:'',data:''} Action Creator 创建action的工厂函数
reducer（老的状态state和action 生成新状态 state纯函数）不修改原来的状态

react-redux插件 简化redux与react耦合度太高的插件 编码不简洁的问题
组件类大写 函数小写 规范
引入Provider 交给它管理store
connect

将所有组件分为ui组件和容器组件
ui组件不使用redux api
容器组件使用
export default connect(
state=>({count:state}),
{action,action1}
)(App)
connect中的对象会解构

redux无法实现异步
用redux-thunk中间件实现
createStore(reducer,applyMiddleware(thunk))
异步action 返回的是函数 fn=(number)=>{return dispatch=>{setTimeout(()=>{dispatch(action(number))})}}
同步action 返回对象

redux调试工具

react-native vue+week
appCan
flutter dart语法 不适合前端

shouldComponentUpdate和componentWillUpdate中调用了setState 会造成循环调用
componentWillReceiveProps 改变父组件的state也可能造成死循环

16版生命周期有改变

jsx实现for循环
class Hello extends React.Component {
render(){
var list = (length) => {
var res = [];
    for(var i = 0; i < length; i++) { res.push(<h2 key={i}>hello react</h2>)
  }
  return res
  }
  return (
  <div>hello {list(this.props.length)}
  </div>
  )
  }
  }

  getInitialState 与 constructor的区别 初始化state
  var PCHeader = React.creatClass ({ 一般用于es5

  getInitialState() {
  return {
  userNickName: '用户',
  userId: 0
  };
  　}
  })

  <></> 是
  <React.Fragment /> 的语法糖。 <></> 语法不能接受键值或属性 聚合一个子元素列表，并且不在DOM中增加额外节点。

  react不存在state数据监听
  state更新的时候是调用的setState方法啊，调用了setstate方法说明state更新了。那这个是肯定要获取更新后的state，然后走更新的生命周期函数。不像vue一样，是用defineProperty定义了属性，一开始就收集好了依赖，那么你设置属性的时候就会触发更新

  React Fiber把更新过程碎片化 解决更新过程是同步的性能问题

  直接修改state，react不会重新render

  react要清除监听和定时器
  倒不是性能的问题，关键在于无法确保回调函数不会在组件卸载后调用。一旦出现该情况，this将变成undefined，代码会报错。
  从这个角度看，任何异步事件都应该在组件卸载时取消订阅/监听，包括pub/sub、dom事件等
  否则当你离开页面之后，如果定时器触发，而你又读取了this之类的参数，直接undefined错误

  react组件名必须大写 不然type类型会变

  static displayName = `withHOC(${WrapComponent.displayName || WrapComponent.name})`;调试时候的名字

  验证props保证组件被正确使用

  var ShowTitle = React.createClass({
  getDefaultProps:function(){
  return{
  title : "百度科技"
  }
  },
  render : function(){
  return <h1>{this.props.title}</h1>
  }
  });

  React.createClass和extends Component的区别主要在于：
  1、语法区别
  createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。createClass方式的方法定义使用逗号,隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6
  class的语法规范。
  2、propType 和 getDefaultProps
  React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.
  React.Component：通过设置两个属性propTypes和defaultProps
  3、状态的区别
  React.createClass：通过getInitialState()方法返回一个包含初始值的对象
  React.Component：通过constructor设置初始状态
  4、this区别
  React.createClass：会正确绑定this
  React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。
  5、Mixins
  React.createClass：使用 React.createClass 的话，我们可以在创建组件时添加一个叫做 mixins
  的属性，并将可供混合的类的集合以数组的形e69da5e887aa7a6431333363396435式赋给 mixins。


  使用ref必须用在【类型式的组件】才起作用，用在【函数式的组件】是无效的。
  React.forwardRef React.createRef 创建和获取ref

  ref不要过度使用 不利于复用

  mixins
  mixins就是将组件里的方法抽出来。实际上Mixins里的this是指向组件的，使用了Mixins以后，组件也可以调用Mixins里的方法。
  class不能用mixins 用高阶组件 或es7装饰器

  单元测试 浅层渲染

  React 合成事件
  如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。
  当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。
  而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）
  所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。

  react写todo list

  econciliation commit 调和

  yeoman搭建自己的脚手架

  replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。使用语法：
  replaceState(object nextState[, function callback])
  nextState，将要设置的新状态，该状态会替换当前的state。
  callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。附上原文出处链接及本声明。

  React.cloneElement( 与creatElement第一个参数不同
  element,
  [props],
  [...children]
  )

  React 获取 url 参数 —— this.props.match

  react重定向
  [<Redirect> 标签]
    <Redirect to={'/default'}/> 【编程式导航方式】 this.props.history.push('/default') 编程式导航 withRouter
      将非路由组件提供{history/match/location} export default withRouter(Nav) const withRouter=( Component )=> () =>
      <Route component={ Component } /> 简化版原理


      ReactJS 的5种路由模式
      我们一直在使用的路由方式是BrowserRouter，也就是浏览器的路由方式，其实React还有几种路由方式：

      1、BrowserRouter：浏览器的路由方式，也就是在开发中最常使用的路由方式

      2、HashRouter：在路径前加入#号成为一个哈希值，Hash模式的好处是，再也不会因为我们刷新而找不到我们的对应路径

      3、MemoryRouter：不存储history，所有路由过程保存在内存里，不能进行前进后退，因为地址栏没有发生任何变化

      4、NativeRouter：经常配合ReactNative使用，多用于移动端

      5、StaticRouter：设置静态路由，需要和后台服务器配合设置，比如设置服务端渲染时使用

      路由链接和非路由链接
      1.路由组件：只有包裹在Route组件里的才能使用`this.props.location`，
      2.非路由组件：假如有个需求，是面包屑或者导航组件里需要拿到`this.props.location`（导航组件或者面包屑一般不会包裹在`Route`里吧），那么直接这么写显然就不行了。
      这个时候`withRouter`修饰一下，就可以这么写了

      route 后可以加render

      redux-saga 异步中间件 其他中间件

      redux-persist持久化数据存储

      createStore es6 声明state
      edux-immutable 统一数据格式 redux-promise 中间件 store.dispatch方法可以接受 Promise 对象作为参数
      异步组件react-loadable withRouter react-transition-group
      createStore(reducer,applyMiddleware(middle1,middle2,middle3)); 添加多个中间件


      replaceReducer是替换当前的reducer的函数，replaceReducer接受一个新的reducer，替换完成之后，会执行 dispatch({ type: ActionTypes.INIT
      }) ，用来初始化store的状态。官方举出了三种replaceReducer的使用场景，分别是：

         1、当你的程序要进行代码分割的时候

          2、当你要动态的加载不同的reducer的时候

          3、当你要实现一个实时reloading机制的时候


      //reducers/counter.js

export default function counter(state = 0, action) {
switch (action.type) {
case 'INCREMENT':
return state + 1
case 'DECREMENT':
return state - 1
default:
return state
}
}

//reducers/index.js

import { combineReducers } from 'redux'
import todos from './todos'
import counter from './counter'

export default combineReducers({
todos,
counter
})